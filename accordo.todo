# Accordo API Refactoring TODO

## Current Problems
- [ ] No clear abstraction layers - CMake builds, pipe management, IPC handling all exposed
- [ ] Scattered concerns - code_gen, communicate, utils in separate modules
- [ ] Hard to use - Formula authors must manage pipes, env vars, processes manually
- [ ] Poor testability - Everything coupled to formula_base
- [ ] No clean imports - `from accordo.python.code_gen import generate_header` is ugly
- [ ] Strings for kernel args - no semantic info, bad for LLM generation

## Proposed Clean API Design

### High-Level User API (3 Main Classes)

```python
from accordo import AccordoValidator, ValidationConfig, ValidationResult

# Clean, simple usage
config = ValidationConfig(
    kernel_name="my_kernel",
    kernel_args=[
        KernelArg(name="result", type="double*", direction="out"),
        KernelArg(name="input", type="const double*", direction="in"),
        KernelArg(name="count", type="unsigned long", direction="in")
    ],
    additional_includes=['"my_types.h"'],  # For custom types
    tolerance=1e-6,
    timeout_multiplier=2.0
)

validator = AccordoValidator(config)
result = validator.validate(reference_app, optimized_app, baseline_time_ms=10.5)

if result.is_valid:
    print(f"✓ Validation passed! {result.num_arrays_validated} arrays matched")
else:
    print(f"✗ Failed: {result.error_message}")
    for m in result.mismatches:
        print(f"  Arg '{m.arg_name}' ({m.arg_type}): max_diff={m.max_difference}")
```

### Package Structure

```
src/accordo/
├── __init__.py              # Public API: AccordoValidator, ValidationConfig, ValidationResult
├── validator.py             # AccordoValidator class
├── config.py                # ValidationConfig, KernelArg dataclasses
├── result.py                # ValidationResult, ArrayMismatch dataclasses
├── exceptions.py            # AccordoError, AccordoBuildError, AccordoTimeoutError, etc.
├── _internal/               # Private implementation (not imported by users)
│   ├── __init__.py
│   ├── builder.py           # AccordoBuilder - manages CMake builds
│   ├── runtime.py           # AccordoRuntime - manages process + IPC
│   ├── codegen.py           # generate_kernel_header() - creates KernelArguments.hpp
│   ├── ipc/
│   │   ├── __init__.py
│   │   ├── communication.py # IPC handle reading/writing
│   │   ├── memory.py        # Device-to-host memory operations
│   │   └── types.py         # Type mappings (float*, int*, etc)
│   └── hip.py               # HIP interop functions
└── cpp/                     # C++ library (unchanged)
    ├── accordo.hpp
    ├── accordo.hip
    └── CMakeLists.txt
```

## Key Design Decisions

### 1. Structured KernelArg (Not Plain Strings)
**Rationale:** LLMs generate JSON better than parsing strings. Named args give better error messages.

```python
# ✅ Structured (LLM-friendly, semantic, extensible)
kernel_args=[
    KernelArg(name="result", type="double*", direction="out"),
    KernelArg(name="input", type="const double*", direction="in")
]

# ❌ Old way (hard for LLM, unclear semantics)
kernel_args=["double*", "const double*"]
```

**Benefits:**
- LLMs excel at generating structured JSON
- Better error messages: "Arg 'result' failed" vs "Arg 0 failed"
- Explicit input/output direction
- Easy to extend with metadata (size, validate flag, etc)
- Backward compat: still accept strings, auto-convert to KernelArg

### 2. No BuildConfig Class
**Rationale:** Build is deterministic, fast, and users don't care about build details.

- Accordo auto-builds on first use
- CMake caching makes rebuilds instant
- Optional kwargs for power users: `force_rebuild=True`, `parallel_jobs=16`

### 3. Flat Arguments Only (For Now)
**Rationale:** 95% of GPU kernels use flat signatures. Nested struct support can be added later.

```python
# ✅ Supported (flat args)
kernel_args=[
    KernelArg("output", "float*"),
    KernelArg("input", "const float*"),
    KernelArg("size", "int")
]

# ❌ Not supported yet (nested)
kernel_args=[
    KernelArg("matrix", "Matrix*")  # Matrix has nested pointers
]

# Future: Add visitor/accessor pattern for nested types
```

### 4. additional_includes for Custom Types
**Rationale:** Accordo generates C++ header, needs includes to define custom types.

```python
config = ValidationConfig(
    kernel_name="my_kernel",
    kernel_args=[
        KernelArg("matrix", "MyMatrix*"),
        KernelArg("data", "__hip_bfloat16*")
    ],
    additional_includes=[
        '"my_app/matrix.h"',     # Custom types
        '<hip/hip_bf16.h>'       # HIP types
    ]
)
```

Generated header:
```cpp
#pragma once
#include <tuple>
#include "my_app/matrix.h"      // User's custom types
#include <hip/hip_bf16.h>       // HIP types

struct KernelArguments {
    MyMatrix* arg0;
    __hip_bfloat16* arg1;

    auto as_tuple() const {
        return std::tie(arg0, arg1);
    }
};
```

## Core Classes Detail

### ValidationConfig
```python
@dataclass
class KernelArg:
    name: str                    # "result", "input", "count"
    type: str                    # "double*", "const float*", "int"
    direction: str = "auto"      # "in", "out", "inout", "auto" (infer from const)

@dataclass
class ValidationConfig:
    kernel_name: str
    kernel_args: list[Union[KernelArg, str, dict]]  # Accepts multiple formats
    additional_includes: list[str] = field(default_factory=list)
    tolerance: float = 1e-6
    timeout_multiplier: float = 2.0
    log_level: str = "WARNING"
```

### ValidationResult
```python
@dataclass
class ArrayMismatch:
    arg_index: int
    arg_name: str
    arg_type: str
    max_difference: float
    mean_difference: float
    reference_sample: np.ndarray
    optimized_sample: np.ndarray

@dataclass
class ValidationResult:
    is_valid: bool
    error_message: Optional[str]
    mismatches: list[ArrayMismatch]
    matched_arrays: dict[str, dict]
    execution_time_ms: dict[str, float]  # {"reference": 10.5, "optimized": 8.3}
    timeout_used: Optional[float]

    @property
    def num_arrays_validated(self) -> int:
        return len(self.matched_arrays) + len(self.mismatches)
```

### AccordoValidator
```python
class AccordoValidator:
    def __init__(
        self,
        config: ValidationConfig,
        accordo_path: Optional[Path] = None,  # Auto-detected
        force_rebuild: bool = False,
        parallel_jobs: int = 16
    ):
        """Initialize validator. Lazy builds on first validate() call."""

    def validate(
        self,
        reference_app: Application,
        optimized_app: Application,
        baseline_time_ms: Optional[float] = None
    ) -> ValidationResult:
        """
        Validate optimized vs reference.

        Args:
            baseline_time_ms: For dynamic timeout (timeout = baseline * multiplier)

        Returns:
            ValidationResult with validation status and details

        Raises:
            AccordoTimeoutError, AccordoProcessError, AccordoBuildError
        """
```

### Exceptions
```python
class AccordoError(Exception): pass
class AccordoBuildError(AccordoError): pass
class AccordoTimeoutError(AccordoError):
    def __init__(self, message, timeout_seconds):
        self.timeout_seconds = timeout_seconds
class AccordoProcessError(AccordoError):
    def __init__(self, message, exit_code=None):
        self.exit_code = exit_code
```

## Integration with IntelliPerf

### Simplified formula_base.py
```python
from accordo import AccordoValidator, ValidationConfig, KernelArg

def correctness_validation_pass(self, kernel, kernel_args, tolerance=1e-6):
    # Create config
    config = ValidationConfig(
        kernel_name=kernel,
        kernel_args=kernel_args,  # List of KernelArg or strings
        tolerance=tolerance
    )

    # Validate
    validator = AccordoValidator(config)
    result = validator.validate(
        reference_app=self._reference_app,
        optimized_app=self._application,
        baseline_time_ms=getattr(self, "baseline_time_ms", None)
    )

    return Result(
        success=result.is_valid,
        error_report=result.error_message if not result.is_valid else ""
    )
```

## Implementation Tasks

- [ ] Create new package structure
- [ ] Implement config.py (ValidationConfig, KernelArg)
- [ ] Implement result.py (ValidationResult, ArrayMismatch)
- [ ] Implement exceptions.py (all custom exceptions)
- [ ] Implement validator.py (AccordoValidator main class)
- [ ] Implement _internal/builder.py (CMake build management)
- [ ] Implement _internal/runtime.py (process + IPC management)
- [ ] Implement _internal/codegen.py (header generation with additional_includes)
- [ ] Implement _internal/ipc/ (communication, memory, types)
- [ ] Update __init__.py (clean public API exports)
- [ ] Update formula_base.py to use new API
- [ ] Write tests for each component
- [ ] Update documentation
- [ ] Migration guide for existing code

## Future Enhancements (Post-Flat-Args)

### Nested Struct Support
```python
# Option 1: User provides accessor
kernel_args=[
    KernelArg(
        name="matrix",
        type="Matrix*",
        nested_pointers=["Matrix.data"],  # Specify nested pointers to validate
        element_type="float*"
    )
]

# Option 2: Type definitions for reflection
type_definitions={
    "Matrix": {
        "fields": [
            {"name": "data", "type": "float*", "validate": True},
            {"name": "rows", "type": "int", "validate": False}
        ]
    }
}
```

### Size Expressions
```python
kernel_args=[
    KernelArg(name="output", type="float*", size_expr="N"),
    KernelArg(name="input", type="float*", size_expr="N*M")
]
```

### Selective Validation
```python
kernel_args=[
    KernelArg(name="output", type="float*", validate=True),
    KernelArg(name="config", type="Config*", validate=False)  # Skip complex structs
]
```

## Notes
- Keep API minimal and clean - no BuildConfig
- Optimize for LLM generation - structured KernelArg over strings
- Start with flat args (95% use case), add nested later
- Auto-build, auto-detect, minimize user configuration
- Clear error messages with named arguments
- Type hints everywhere for IDE support

