--- ITERATION 1 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def gravity_potential_kernel(
    grid_ptr, masses_ptr, pos_ptr,
    Nx, Ny, n_masses,
    stride_x, stride_y,
    BLOCK_SIZE_X: tl.constexpr, BLOCK_SIZE_Y: tl.constexpr
):
    pid_x = tl.program_id(0)
    pid_y = tl.program_id(1)

    # Swizzle the program IDs using a Z-order curve
    def interleave_bits(x, y):
        z = 0
        for i in range(max(x.bit_length(), y.bit_length())):
            z |= ((x & (1 << i)) << i) | ((y & (1 << i)) << (i + 1))
        return z

    pid = interleave_bits(pid_x, pid_y)

    offsets_x = pid * BLOCK_SIZE_X + tl.arange(0, BLOCK_SIZE_X)
    offsets_y = pid_y * BLOCK_SIZE_Y + tl.arange(0, BLOCK_SIZE_Y)

    # Grid point coordinates
    grid_x = offsets_x[:, None]
    grid_y = offsets_y[None, :]

    potential = tl.zeros((BLOCK_SIZE_X, BLOCK_SIZE_Y), dtype=tl.float32)

    for i in range(0, n_masses):
        mass = tl.load(masses_ptr + i)
        mass_x = tl.load(pos_ptr + i)
        mass_y = tl.load(pos_ptr + n_masses + i)
        
        dx = grid_x - mass_x
        dy = grid_y - mass_y
        
        dist_sq = dx*dx + dy*dy
        dist = tl.sqrt(dist_sq + 1e-6) # Add epsilon to avoid division by zero
        
        potential -= mass / dist

    grid_ptrs = grid_ptr + (offsets_x[:, None] * stride_x + offsets_y[None, :] * stride_y)
    mask = (offsets_x[:, None] < Nx) & (offsets_y[None, :] < Ny)
    tl.store(grid_ptrs, potential, mask=mask)

--- ITERATION 2 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def gravity_potential_kernel(
    grid_ptr, masses_ptr, pos_ptr,
    Nx, Ny, n_masses,
    stride_x, stride_y,
    BLOCK_SIZE_X: tl.constexpr, BLOCK_SIZE_Y: tl.constexpr
):
    pid_x = tl.program_id(0)
    pid_y = tl.program_id(1)

    # Inline the interleave_bits logic to avoid nested function
    z = 0
    for i in range(max(pid_x.bit_length(), pid_y.bit_length())):
        z |= ((pid_x & (1 << i)) << i) | ((pid_y & (1 << i)) << (i + 1))
    pid = z

    offsets_x = pid * BLOCK_SIZE_X + tl.arange(0, BLOCK_SIZE_X)
    offsets_y = pid_y * BLOCK_SIZE_Y + tl.arange(0, BLOCK_SIZE_Y)

    # Grid point coordinates
    grid_x = offsets_x[:, None]
    grid_y = offsets_y[None, :]

    potential = tl.zeros((BLOCK_SIZE_X, BLOCK_SIZE_Y), dtype=tl.float32)

    for i in range(0, n_masses):
        mass = tl.load(masses_ptr + i)
        mass_x = tl.load(pos_ptr + i)
        mass_y = tl.load(pos_ptr + n_masses + i)
        
        dx = grid_x - mass_x
        dy = grid_y - mass_y
        
        dist_sq = dx*dx + dy*dy
        dist = tl.sqrt(dist_sq + 1e-6) # Add epsilon to avoid division by zero
        
        potential -= mass / dist

    grid_ptrs = grid_ptr + (offsets_x[:, None] * stride_x + offsets_y[None, :] * stride_y)
    mask = (offsets_x[:, None] < Nx) & (offsets_y[None, :] < Ny)
    tl.store(grid_ptrs, potential, mask=mask)

--- ITERATION 3 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def gravity_potential_kernel(
    grid_ptr, masses_ptr, pos_ptr,
    Nx, Ny, n_masses,
    stride_x, stride_y,
    BLOCK_SIZE_X: tl.constexpr, BLOCK_SIZE_Y: tl.constexpr
):
    pid_x = tl.program_id(0)
    pid_y = tl.program_id(1)

    # Remap pid using block swizzling
    z = tl.zeros((1,), dtype=tl.int32)
    for i in range(32):  # Assuming 32-bit integers
        z |= ((pid_x & (1 << i)) << i) | ((pid_y & (1 << i)) << (i + 1))
    pid = z[0]

    offsets_x = pid * BLOCK_SIZE_X + tl.arange(0, BLOCK_SIZE_X)
    offsets_y = pid_y * BLOCK_SIZE_Y + tl.arange(0, BLOCK_SIZE_Y)

    # Grid point coordinates
    grid_x = offsets_x[:, None]
    grid_y = offsets_y[None, :]

    potential = tl.zeros((BLOCK_SIZE_X, BLOCK_SIZE_Y), dtype=tl.float32)

    for i in range(0, n_masses):
        mass = tl.load(masses_ptr + i)
        mass_x = tl.load(pos_ptr + i)
        mass_y = tl.load(pos_ptr + n_masses + i)
        
        dx = grid_x - mass_x
        dy = grid_y - mass_y
        
        dist_sq = dx*dx + dy*dy
        dist = tl.sqrt(dist_sq + 1e-6) # Add epsilon to avoid division by zero
        
        potential -= mass / dist

    grid_ptrs = grid_ptr + (offsets_x[:, None] * stride_x + offsets_y[None, :] * stride_y)
    mask = (offsets_x[:, None] < Nx) & (offsets_y[None, :] < Ny)
    tl.store(grid_ptrs, potential, mask=mask)

--- ITERATION 4 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def gravity_potential_kernel(
    grid_ptr, masses_ptr, pos_ptr,
    Nx, Ny, n_masses,
    stride_x, stride_y,
    BLOCK_SIZE_X: tl.constexpr, BLOCK_SIZE_Y: tl.constexpr
):
    pid_x = tl.program_id(0)
    pid_y = tl.program_id(1)

    # Remap pid using block swizzling
    pid = (pid_y << 16) | pid_x

    offsets_x = pid * BLOCK_SIZE_X + tl.arange(0, BLOCK_SIZE_X)
    offsets_y = pid_y * BLOCK_SIZE_Y + tl.arange(0, BLOCK_SIZE_Y)

    # Grid point coordinates
    grid_x = offsets_x[:, None]
    grid_y = offsets_y[None, :]

    potential = tl.zeros((BLOCK_SIZE_X, BLOCK_SIZE_Y), dtype=tl.float32)

    for i in range(0, n_masses):
        mass = tl.load(masses_ptr + i)
        mass_x = tl.load(pos_ptr + i)
        mass_y = tl.load(pos_ptr + n_masses + i)
        
        dx = grid_x - mass_x
        dy = grid_y - mass_y
        
        dist_sq = dx*dx + dy*dy
        dist = tl.sqrt(dist_sq + 1e-6) # Add epsilon to avoid division by zero
        
        potential -= mass / dist

    grid_ptrs = grid_ptr + (offsets_x[:, None] * stride_x + offsets_y[None, :] * stride_y)
    mask = (offsets_x[:, None] < Nx) & (offsets_y[None, :] < Ny)
    tl.store(grid_ptrs, potential, mask=mask)

--- PROFILING REPORT (ITERATION 4) ---
L2 Cache Locality Improvement: Successfully improved L2 cache hit rate by 11.84 percentage points. Hit rate increased from 87.7% to 99.5% (higher percentages indicate better cache locality through improved block swizzling). Performance Gain: Achieved 1.07x speedup with execution time reduced from 5.48ms to 5.10ms (7.4% faster).

--- ITERATION 5 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def gravity_potential_kernel(
    grid_ptr, masses_ptr, pos_ptr,
    Nx, Ny, n_masses,
    stride_x, stride_y,
    BLOCK_SIZE_X: tl.constexpr, BLOCK_SIZE_Y: tl.constexpr
):
    pid_x = tl.program_id(0)
    pid_y = tl.program_id(1)

    # Remap pid using block swizzling
    pid = (pid_y << 16) | pid_x

    offsets_x = pid * BLOCK_SIZE_X + tl.arange(0, BLOCK_SIZE_X)
    offsets_y = pid_y * BLOCK_SIZE_Y + tl.arange(0, BLOCK_SIZE_Y)

    # Grid point coordinates
    grid_x = offsets_x[:, None]
    grid_y = offsets_y[None, :]

    potential = tl.zeros((BLOCK_SIZE_X, BLOCK_SIZE_Y), dtype=tl.float32)

    for i in range(0, n_masses):
        mass = tl.load(masses_ptr + i)
        mass_x = tl.load(pos_ptr + i)
        mass_y = tl.load(pos_ptr + n_masses + i)
        
        dx = grid_x - mass_x
        dy = grid_y - mass_y
        
        dist_sq = dx*dx + dy*dy
        dist = tl.sqrt(dist_sq + 1e-6) # Add epsilon to avoid division by zero
        
        potential -= mass / dist

    grid_ptrs = grid_ptr + (offsets_x[:, None] * stride_x + offsets_y[None, :] * stride_y)
    mask = (offsets_x[:, None] < Nx) & (offsets_y[None, :] < Ny)
    tl.store(grid_ptrs, potential, mask=mask)

--- PROFILING REPORT (ITERATION 5) ---
L2 Cache Locality Improvement: Successfully improved L2 cache hit rate by 11.84 percentage points. Hit rate increased from 87.7% to 99.5% (higher percentages indicate better cache locality through improved block swizzling). Performance Gain: Achieved 1.08x speedup with execution time reduced from 5.48ms to 5.08ms (8.0% faster).

--- ITERATION 6 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def gravity_potential_kernel(
    grid_ptr, masses_ptr, pos_ptr,
    Nx, Ny, n_masses,
    stride_x, stride_y,
    BLOCK_SIZE_X: tl.constexpr, BLOCK_SIZE_Y: tl.constexpr
):
    pid_x = tl.program_id(0)
    pid_y = tl.program_id(1)

    # Remap pid using block swizzling
    pid = (pid_y << 16) | pid_x

    offsets_x = pid * BLOCK_SIZE_X + tl.arange(0, BLOCK_SIZE_X)
    offsets_y = pid_y * BLOCK_SIZE_Y + tl.arange(0, BLOCK_SIZE_Y)

    # Grid point coordinates
    grid_x = offsets_x[:, None]
    grid_y = offsets_y[None, :]

    potential = tl.zeros((BLOCK_SIZE_X, BLOCK_SIZE_Y), dtype=tl.float32)

    for i in range(0, n_masses):
        mass = tl.load(masses_ptr + i)
        mass_x = tl.load(pos_ptr + i)
        mass_y = tl.load(pos_ptr + n_masses + i)
        
        dx = grid_x - mass_x
        dy = grid_y - mass_y
        
        dist_sq = dx*dx + dy*dy
        dist = tl.sqrt(dist_sq + 1e-6) # Add epsilon to avoid division by zero
        
        potential -= mass / dist

    grid_ptrs = grid_ptr + (offsets_x[:, None] * stride_x + offsets_y[None, :] * stride_y)
    mask = (offsets_x[:, None] < Nx) & (offsets_y[None, :] < Ny)
    tl.store(grid_ptrs, potential, mask=mask)

--- PROFILING REPORT (ITERATION 6) ---
L2 Cache Locality Improvement: Successfully improved L2 cache hit rate by 11.84 percentage points. Hit rate increased from 87.7% to 99.5% (higher percentages indicate better cache locality through improved block swizzling). Performance Gain: Achieved 1.08x speedup with execution time reduced from 5.48ms to 5.09ms (7.7% faster).

--- ITERATION 7 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def gravity_potential_kernel(
    grid_ptr, masses_ptr, pos_ptr,
    Nx, Ny, n_masses,
    stride_x, stride_y,
    BLOCK_SIZE_X: tl.constexpr, BLOCK_SIZE_Y: tl.constexpr
):
    pid_x = tl.program_id(0)
    pid_y = tl.program_id(1)

    # Remap pid using block swizzling
    pid = (pid_y << 16) | pid_x

    offsets_x = pid * BLOCK_SIZE_X + tl.arange(0, BLOCK_SIZE_X)
    offsets_y = pid_y * BLOCK_SIZE_Y + tl.arange(0, BLOCK_SIZE_Y)

    # Grid point coordinates
    grid_x = offsets_x[:, None]
    grid_y = offsets_y[None, :]

    potential = tl.zeros((BLOCK_SIZE_X, BLOCK_SIZE_Y), dtype=tl.float32)

    for i in range(0, n_masses):
        mass = tl.load(masses_ptr + i)
        mass_x = tl.load(pos_ptr + i)
        mass_y = tl.load(pos_ptr + n_masses + i)
        
        dx = grid_x - mass_x
        dy = grid_y - mass_y
        
        dist_sq = dx*dx + dy*dy
        dist = tl.sqrt(dist_sq + 1e-6) # Add epsilon to avoid division by zero
        
        potential -= mass / dist

    grid_ptrs = grid_ptr + (offsets_x[:, None] * stride_x + offsets_y[None, :] * stride_y)
    mask = (offsets_x[:, None] < Nx) & (offsets_y[None, :] < Ny)
    tl.store(grid_ptrs, potential, mask=mask)

