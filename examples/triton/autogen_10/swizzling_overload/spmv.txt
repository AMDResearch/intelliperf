--- ITERATION 1 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def spmv_kernel(
    y_ptr, x_ptr,
    data_ptr, indices_ptr, indptr_ptr,
    M,
    BLOCK_SIZE: tl.constexpr
):
    pid = tl.program_id(0)
    # Apply block swizzling to remap pid for better cache locality
    num_blocks = (M + BLOCK_SIZE - 1) // BLOCK_SIZE
    block_x = pid % num_blocks
    block_y = pid // num_blocks
    pid = block_y + block_x * num_blocks
    
    row_start = tl.load(indptr_ptr + pid)
    row_end = tl.load(indptr_ptr + pid + 1)
    
    acc = 0.0
    for i in range(row_start, row_end, BLOCK_SIZE):
        offsets = i + tl.arange(0, BLOCK_SIZE)
        mask = offsets < row_end
        
        col_indices = tl.load(indices_ptr + offsets, mask=mask)
        data = tl.load(data_ptr + offsets, mask=mask)
        x_vals = tl.load(x_ptr + col_indices, mask=mask)
        
        acc += tl.sum(data * x_vals)
        
    tl.store(y_ptr + pid, acc)

--- PROFILING REPORT (ITERATION 1) ---
L2 Cache Locality Improvement: Successfully improved L2 cache hit rate by 7.98 percentage points. Hit rate increased from 29.0% to 37.0% (higher percentages indicate better cache locality through improved block swizzling). Performance Gain: Achieved 1.01x speedup with execution time reduced from 0.01ms to 0.01ms (1.0% faster).

--- ITERATION 2 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def spmv_kernel(
    y_ptr, x_ptr,
    data_ptr, indices_ptr, indptr_ptr,
    M,
    BLOCK_SIZE: tl.constexpr
):
    pid = tl.program_id(0)
    # Apply block swizzling to remap pid for better cache locality
    num_blocks = (M + BLOCK_SIZE - 1) // BLOCK_SIZE
    block_x = pid % num_blocks
    block_y = pid // num_blocks
    pid = block_y + block_x * num_blocks
    
    row_start = tl.load(indptr_ptr + pid)
    row_end = tl.load(indptr_ptr + pid + 1)
    
    acc = 0.0
    for i in range(row_start, row_end, BLOCK_SIZE):
        offsets = i + tl.arange(0, BLOCK_SIZE)
        mask = offsets < row_end
        
        col_indices = tl.load(indices_ptr + offsets, mask=mask)
        data = tl.load(data_ptr + offsets, mask=mask)
        x_vals = tl.load(x_ptr + col_indices, mask=mask)
        
        acc += tl.sum(data * x_vals)
        
    tl.store(y_ptr + pid, acc)

--- PROFILING REPORT (ITERATION 2) ---
L2 Cache Locality Improvement: Successfully improved L2 cache hit rate by 7.96 percentage points. Hit rate increased from 29.0% to 37.0% (higher percentages indicate better cache locality through improved block swizzling). Performance Gain: Achieved 1.02x speedup with execution time reduced from 0.01ms to 0.01ms (2.4% faster).

--- ITERATION 3 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def spmv_kernel(
    y_ptr, x_ptr,
    data_ptr, indices_ptr, indptr_ptr,
    M,
    BLOCK_SIZE: tl.constexpr
):
    pid = tl.program_id(0)
    # Apply block swizzling to remap pid for better cache locality
    num_blocks = (M + BLOCK_SIZE - 1) // BLOCK_SIZE
    block_x = pid % num_blocks
    block_y = pid // num_blocks
    pid = block_y + block_x * num_blocks
    
    row_start = tl.load(indptr_ptr + pid)
    row_end = tl.load(indptr_ptr + pid + 1)
    
    acc = 0.0
    for i in range(row_start, row_end, BLOCK_SIZE):
        offsets = i + tl.arange(0, BLOCK_SIZE)
        mask = offsets < row_end
        
        col_indices = tl.load(indices_ptr + offsets, mask=mask)
        data = tl.load(data_ptr + offsets, mask=mask)
        x_vals = tl.load(x_ptr + col_indices, mask=mask)
        
        acc += tl.sum(data * x_vals)
        
    tl.store(y_ptr + pid, acc)

--- PROFILING REPORT (ITERATION 3) ---
L2 Cache Locality Improvement: Successfully improved L2 cache hit rate by 8.01 percentage points. Hit rate increased from 29.0% to 37.0% (higher percentages indicate better cache locality through improved block swizzling). Performance Gain: Achieved 1.02x speedup with execution time reduced from 0.01ms to 0.01ms (1.7% faster).

--- ITERATION 4 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def spmv_kernel(
    y_ptr, x_ptr,
    data_ptr, indices_ptr, indptr_ptr,
    M,
    BLOCK_SIZE: tl.constexpr
):
    pid = tl.program_id(0)
    # Apply block swizzling to remap pid for better cache locality
    num_blocks = (M + BLOCK_SIZE - 1) // BLOCK_SIZE
    block_x = pid % num_blocks
    block_y = pid // num_blocks
    pid = block_y + block_x * num_blocks
    
    row_start = tl.load(indptr_ptr + pid)
    row_end = tl.load(indptr_ptr + pid + 1)
    
    acc = 0.0
    for i in range(row_start, row_end, BLOCK_SIZE):
        offsets = i + tl.arange(0, BLOCK_SIZE)
        mask = offsets < row_end
        
        col_indices = tl.load(indices_ptr + offsets, mask=mask)
        data = tl.load(data_ptr + offsets, mask=mask)
        x_vals = tl.load(x_ptr + col_indices, mask=mask)
        
        acc += tl.sum(data * x_vals)
        
    tl.store(y_ptr + pid, acc)

--- PROFILING REPORT (ITERATION 4) ---
L2 Cache Locality Improvement: Successfully improved L2 cache hit rate by 8.02 percentage points. Hit rate increased from 29.0% to 37.0% (higher percentages indicate better cache locality through improved block swizzling). Performance Gain: Achieved 1.01x speedup with execution time reduced from 0.01ms to 0.01ms (0.8% faster).

--- ITERATION 5 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def spmv_kernel(
    y_ptr, x_ptr,
    data_ptr, indices_ptr, indptr_ptr,
    M,
    BLOCK_SIZE: tl.constexpr
):
    pid = tl.program_id(0)
    # Apply block swizzling to remap pid for better cache locality
    num_blocks = (M + BLOCK_SIZE - 1) // BLOCK_SIZE
    block_x = pid % num_blocks
    block_y = pid // num_blocks
    pid = block_y + block_x * num_blocks
    
    row_start = tl.load(indptr_ptr + pid)
    row_end = tl.load(indptr_ptr + pid + 1)
    
    acc = 0.0
    for i in range(row_start, row_end, BLOCK_SIZE):
        offsets = i + tl.arange(0, BLOCK_SIZE)
        mask = offsets < row_end
        
        col_indices = tl.load(indices_ptr + offsets, mask=mask)
        data = tl.load(data_ptr + offsets, mask=mask)
        x_vals = tl.load(x_ptr + col_indices, mask=mask)
        
        acc += tl.sum(data * x_vals)
        
    tl.store(y_ptr + pid, acc)

--- PROFILING REPORT (ITERATION 5) ---
L2 Cache Locality Improvement: Successfully improved L2 cache hit rate by 8.01 percentage points. Hit rate increased from 29.0% to 37.0% (higher percentages indicate better cache locality through improved block swizzling). Performance Gain: Achieved 1.01x speedup with execution time reduced from 0.01ms to 0.01ms (1.3% faster).

--- ITERATION 6 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def spmv_kernel(
    y_ptr, x_ptr,
    data_ptr, indices_ptr, indptr_ptr,
    M,
    BLOCK_SIZE: tl.constexpr
):
    pid = tl.program_id(0)
    # Apply block swizzling to remap pid for better cache locality
    num_blocks = (M + BLOCK_SIZE - 1) // BLOCK_SIZE
    block_x = pid % num_blocks
    block_y = pid // num_blocks
    pid = block_y + block_x * num_blocks
    
    row_start = tl.load(indptr_ptr + pid)
    row_end = tl.load(indptr_ptr + pid + 1)
    
    acc = 0.0
    for i in range(row_start, row_end, BLOCK_SIZE):
        offsets = i + tl.arange(0, BLOCK_SIZE)
        mask = offsets < row_end
        
        col_indices = tl.load(indices_ptr + offsets, mask=mask)
        data = tl.load(data_ptr + offsets, mask=mask)
        x_vals = tl.load(x_ptr + col_indices, mask=mask)
        
        acc += tl.sum(data * x_vals)
        
    tl.store(y_ptr + pid, acc)

--- PROFILING REPORT (ITERATION 6) ---
L2 Cache Locality Improvement: Successfully improved L2 cache hit rate by 7.98 percentage points. Hit rate increased from 29.0% to 37.0% (higher percentages indicate better cache locality through improved block swizzling). Performance Gain: Achieved 1.13x speedup with execution time reduced from 0.01ms to 0.01ms (13.5% faster).

--- ITERATION 7 ---
--- OPTIMIZATION RESPONSE (OPTIMIZED KERNEL) ---
#!/usr/bin/env python

import triton
import triton.language as tl


@triton.jit
def spmv_kernel(
    y_ptr, x_ptr,
    data_ptr, indices_ptr, indptr_ptr,
    M,
    BLOCK_SIZE: tl.constexpr
):
    pid = tl.program_id(0)
    # Apply block swizzling to remap pid for better cache locality
    num_blocks = (M + BLOCK_SIZE - 1) // BLOCK_SIZE
    block_x = pid % num_blocks
    block_y = pid // num_blocks
    pid = block_y + block_x * num_blocks
    
    row_start = tl.load(indptr_ptr + pid)
    row_end = tl.load(indptr_ptr + pid + 1)
    
    acc = 0.0
    for i in range(row_start, row_end, BLOCK_SIZE):
        offsets = i + tl.arange(0, BLOCK_SIZE)
        mask = offsets < row_end
        
        col_indices = tl.load(indices_ptr + offsets, mask=mask)
        data = tl.load(data_ptr + offsets, mask=mask)
        x_vals = tl.load(x_ptr + col_indices, mask=mask)
        
        acc += tl.sum(data * x_vals)
        
    tl.store(y_ptr + pid, acc)

