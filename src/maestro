#!/usr/bin/env python3

import argparse
import logging
from formulas.bank_conflict import bank_conflict

def maestro_parser():
    parser = argparse.ArgumentParser(
        description='Optimize the given application based on available Maestro formulas.',
        prog="tool",
        formatter_class=lambda prog: argparse.RawTextHelpFormatter(
            prog, max_help_position=30
        ),
        usage="""
        maestro -n <workload_name> [options] -- <profile_cmd>

        Example:
        maestro -n rocblas_gemm -- ~/rocBLAS/build/bin/rocblas_gemm
        """,
    )
    parser.add_argument('-v', '--verbose', action='count', default=0, help='Increase verbosity level (e.g., -v, -vv, -vvv).')
    parser.add_argument('-n', '--name', type=str, required=True, help='Assign a name to distinguish your Maestro run.')
    parser.add_argument('-s', '--script', type=str, required=True, help='A script to build your application.')
    parser.add_argument('remaining', metavar="-- [ ...]", nargs=argparse.REMAINDER, help='Provide the command to launch the application.')
    #TODO: Support different formulas via the `-f` option?
    parser.add_argument('-f', '--formula', type=str, help='Specify the formula to use for optimization.')

    args = parser.parse_args()
    return args

def main():
    logging.raiseExceptions = True
    args = maestro_parser()
    # Set logging level based on verbosity
    if args.verbose == 1:
        logging.basicConfig(level=logging.INFO)
    elif args.verbose == 2:
        logging.basicConfig(level=logging.DEBUG)
    elif args.verbose >= 3:
        logging.basicConfig(level=logging.NOTSET)
    else:
        logging.basicConfig(level=logging.WARNING)

    # Create an optimizer based on available Maestro formulas.
    optimizer = bank_conflict(
        name=args.name, 
        build_script=args.script, 
        app_cmd=args.remaining,
        only_consider_top_kernel=True
    )

    # Build the application
    optimizer.build()

    # Profile the application and collect the results.
    profiler_results = optimizer.profile_pass()

    # Instrument the application based on the results.
    instrument_results = optimizer.instrument_pass(perf_report_card=profiler_results.asset)
    instrument_results.report_out()

    # Optimize the application based on insights from instrumentation.
    optimizer_results = optimizer.optimize_pass(file = instrument_results.asset["file"],
                                                kernel = instrument_results.asset["kernel"],
                                                lines = instrument_results.asset["lines"])
    optimizer_results.report_out()

    # Compile the new application
    compiler_results = optimizer.compiler_pass(file=optimizer_results.asset)
    compiler_results.report_out()

    # Find the performance results
    validation_results = optimizer.validation_pass(optimized_binary = compiler_results["binary"],
                                                    kernel = instrument_results.asset["kernel"],
                                                    args = instrument_results.asset["arguments"])
    validation_results.report_out()

    # Find the performance results
    performance_results = optimizer.performance_pass(optimized_binary=compiler_results.asset)
    performance_results.report_out()


    return


if __name__ == '__main__':
    main()
