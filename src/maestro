#!/usr/bin/env python3

import sys
import argparse
import logging
import json
from datetime import datetime
from formulas.bank_conflict import bank_conflict
from formulas.diagnose_only import diagnose_only
from tabulate import tabulate

def maestro_parser():
    parser = argparse.ArgumentParser(
        description='Optimize the given application based on available Maestro formulas.',
        prog="tool",
        formatter_class=lambda prog: argparse.RawTextHelpFormatter(
            prog, max_help_position=30
        ),
        usage="""
        maestro [options] -- <profile_cmd>

        Example:
        maestro -s ~/rocBLAS/build.sh -- ~/rocBLAS/build/bin/rocblas_gemm
        """,
    )
    parser.add_argument('-v', '--verbose', action='count', default=0, help='Increase verbosity level (e.g., -v, -vv, -vvv).')
    # Required arguments group
    required_args = parser.add_argument_group('required arguments')
    required_args.add_argument('-s', '--script', type=str, required=True, help='A script to build your application.')
    required_args.add_argument('remaining', metavar="-- [ ...]", nargs=argparse.REMAINDER, help='Provide the command to launch the application.')

    # Optional arguments group
    optional_args = parser.add_argument_group('optional arguments')
    optional_args.add_argument('-f', '--formula', choices=['bankConflict', 'diagnoseOnly'], default='diagnoseOnly', type=str, help='Specify the formula to use for optimization (default: diagnoseOnly).')
    optional_args.add_argument("-o", "--output_file", type=str, help="Path to the output file (optional)")
    optional_args.add_argument("-c", "--ci_output_file", type=str, help="Path to the output file for CI integration (optional)")

    args = parser.parse_args()
    return args

def main():
    logging.raiseExceptions = True
    args = maestro_parser()
    # Generate a name for the Maestro run using timestamp
    generated_name = datetime.now().strftime("%Y_%m_%d~%H_%M_%S")
    # Set logging level based on verbosity
    if args.verbose == 1:
        logging.basicConfig(level=logging.INFO, format="[MAESTRO] %(levelname)s: %(message)s")
    elif args.verbose == 2:
        logging.basicConfig(level=logging.DEBUG, format="[MAESTRO] %(levelname)s: %(message)s")
    elif args.verbose >= 3:
        logging.basicConfig(level=logging.NOTSET, format="[MAESTRO] %(levelname)s: %(message)s")
    else:
        logging.basicConfig(level=logging.WARNING, format="[MAESTRO] %(levelname)s: %(message)s")

    # Create an optimizer based on available Maestro formulas.
    if args.formula == 'bankConflict':
        optimizer = bank_conflict(
            name=generated_name,
            build_script=args.script,
            app_cmd=args.remaining,
            only_consider_top_kernel=True
        )
    elif args.formula == 'diagnoseOnly':
        optimizer = diagnose_only(
            name=generated_name,
            build_script=args.script,
            app_cmd=args.remaining
        )
    else:
        logging.error(f"Invalid formula specified. {args.formula} is not supported.")
        sys.exit(1)

    # Build the application
    build_results = optimizer.build()
    build_results.report_out()

    # Profile the application and collect the results.
    unoptimized_binary_profiler_results = optimizer.profile_pass()

    if args.formula != 'diagnoseOnly':
        # Instrument the application based on the results.
        instrument_results = optimizer.instrument_pass(perf_report_card=unoptimized_binary_profiler_results.asset)
        instrument_results.report_out()

        # Optimize the application based on insights from instrumentation.
        optimizer_results = optimizer.optimize_pass(file = instrument_results.asset["file"],
                                                    kernel = instrument_results.asset["kernel"],
                                                    lines = instrument_results.asset["lines"])
        optimizer_results.report_out()

        # Compile the new application
        # Backup the unoptimized binary
        unoptimized_binary = optimizer.backup("unoptimized")
        compiler_results = optimizer.build()
        compiler_results.report_out()

        # Backup the optimized binary
        optimized_binary = optimizer.backup("optimized")

        # Find the performance results
        validation_results = optimizer.validation_pass(unoptimized_binary = unoptimized_binary,
                                                    optimized_binary = optimized_binary,
                                                    kernel = instrument_results.asset["kernel"],
                                                    args = instrument_results.asset["arguments"])
        validation_results.report_out()

        # Find the performance results
        # We updated and built the optimized code, now we can just run the 
        # profiling pass 
        optimized_binary_profiler_results = optimizer.profile_pass()
        optimized_binary_profiler_results.report_out()
        
        logging.info("Optimized code:")
        logging.info(tabulate(optimized_binary_profiler_results.asset, headers='keys', tablefmt='psql'))
        logging.info("Unoptimized code:")
        logging.info(tabulate(unoptimized_binary_profiler_results.asset, headers='keys', tablefmt='psql'))

        performance_results = optimizer.performance_pass(unoptimized_binary_result=unoptimized_binary_profiler_results,
                                                        optimized_binary_result=optimized_binary_profiler_results,
                                                        kernel_signature=instrument_results.asset["kernel_signature"] )
        performance_results.report_out()
    # Write output
    
    log = json.dumps(unoptimized_binary_profiler_results.asset, indent=4) if args.formula == "diagnoseOnly" else performance_results.asset['log']
    if args.output_file:
        with open(args.output_file, 'w') as f:
            f.write(log)
    else:
        print(log)
        
    if args.ci_output_file and args.formula != "diagnoseOnly":
        kernel = instrument_results.asset['kernel']
        lines = instrument_results.asset['lines']
        
        message = (f"Maestro detected bank conflicts in the kernel `{kernel}` at line(s) {lines}." 
                   f" This PR contains an optimized and validated implementation. See log below for complete output.")
        with open(args.ci_output_file, 'w') as f:
            f.write(message)
        

if __name__ == '__main__':
    main()
